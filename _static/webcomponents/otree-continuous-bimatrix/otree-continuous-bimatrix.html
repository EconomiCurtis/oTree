<link
        rel="import"
        href="/static/bower_components/polymer/polymer.html"/>
<link
        rel="import"
        href="/static/bower_components/polymerfire/firebase-document.html"/>
<link
        rel="import"
        href="/static/webcomponents/otree-vars/otree-vars.html"/>
<link
        rel="import"
        href="/static/webcomponents/otree-log/otree-log.html"/>

<script src="heatmap.js"></script>

<!--
`<otree-bimatrix>` lets subjects select a strategy from a set of
possibilities. Their decision and the results are  displayed using the usual
matrix form.

Example:

    <otree-bimatrix
        row-labels='["Cooperate", "Defect"]'
        payoff-matrix=
        '[
            [
                "{{ Constants.cooperate_amount }}",
                "{{ Constants.cooperate_amount }}"
            ],
            [
                "{{ Constants.cooperate_defect_amount }}",
                "{{ Constants.defect_cooperate_amount }}"
            ],
            [
                "{{ Constants.defect_cooperate_amount }}",
                "{{ Constants.cooperate_defect_amount }}"
            ],
            [
                "{{ Constants.defect_amount }}",
                "{{ Constants.defect_amount }}"
            ]
            payoff-index='{{ player.id_in_group|add:"-1" }}'
        ]'>
    </otree-bimatrix>
-->
<dom-module id="otree-continuous-bimatrix">

    <template>

        <link rel="stylesheet" type="text/css" href="styles.css">

        <!--
        polymer element to interface with firebase
        takes a path as its path attribute and makes data reflect whatever is stored in firebase at that path-->
        <firebase-document
                id="fbdoc"
                path="[[path_]]"
                data="{{ decisions }}">
        </firebase-document>

        <!--
        polymer element with useful otree variables as attributes (current group, round, etc.)
        -->
        <otree-vars id="vars"></otree-vars>

        <otree-log id="log"></otree-log>

        <!--
        container for both heatmaps
        only contains this player's heatmap if the opponent heatmap option is not specified
        -->
        <div style="text-align: center">
            <div id="my-bimatrix-container">
                <!--
                slider for choosing strategy
                -->
                <input id="slider" type="range" min="0" max="1" step=".01" defaultValue=".5" on-up="_setMyDecision"/>
                <div id="my-heatmap">
                    <!--
                    canvas will be filled with heatmap in javascript
                    see heatmap.js
                    -->
                    <canvas width="360" height="360" id="my-canvas"></canvas>
                    <!--
                    labels showing payoff at each corner of heatmap
                    -->
                    <span class="payoff_labels" style="top: -25px; left: 10px;">[[_payoff(payoffMatrix.*, 0, payoffIndex)]]</span>
                    <span class="payoff_labels" style="top: -25px; right: 10px;">[[_payoff(payoffMatrix.*, 1, payoffIndex)]]</span>
                    <span class="payoff_labels" style="bottom: -25px; left: 10px;">[[_payoff(payoffMatrix.*, 2, payoffIndex)]]</span>
                    <span class="payoff_labels" style="bottom: -25px; right: 10px;">[[_payoff(payoffMatrix.*, 3, payoffIndex)]]</span>
                    <!--
                    lines showing current strategy and opponent's strategy
                    set height or width using data binding and set a border on only one side to make a moving line
                    -->
                    <div id="my-val" style$="height: [[_calcPercent(my_decision)]];"></div>
                    <div id="other-val" style$="width: [[_calcPercent(other_decision)]];"></div>
                </div>
            </div>
            <!--
            other heatmap is exactly the same as this player's, just smaller
            container is hidden by default, but is unhidden in js if opponent heatmap option is chosen
            -->
            <div id="other-bimatrix-container" style="display: none">
                <div id="other-heatmap">
                    <canvas width="240" height="240" id="other-canvas"></canvas>
                    <span class="payoff_labels" style="top: -25px; left: 10px;">[[_payoff(payoffMatrix.*, 0, otherPayoffIndex)]]</span>
                    <span class="payoff_labels" style="top: -25px; right: 10px;">[[_payoff(payoffMatrix.*, 2, otherPayoffIndex)]]</span>
                    <span class="payoff_labels" style="bottom: -25px; left: 10px;">[[_payoff(payoffMatrix.*, 1, otherPayoffIndex)]]</span>
                    <span class="payoff_labels" style="bottom: -25px; right: 10px;">[[_payoff(payoffMatrix.*, 3, otherPayoffIndex)]]</span>
                    <div id="my-val" style$="height: [[_calcPercent(my_decision)]];"></div>
                    <div id="other-val" style$="width: [[_calcPercent(other_decision)]];"></div>
                </div>
            </div>
        </div>

        <div class="graph-container">
            <canvas id="thermometer"></canvas>
            <div id="payoff_graph"></div>
        </div>
        <div id="strategy_graph"</div>
    </template>

    <script>
        Polymer({
            is: 'otree-continuous-bimatrix',
            properties: {
                // labels for strategies. not currently being used
                rowLabels: Array,
                // 2x2 array of payoffs for each player. see block comment at top for details
                payoffMatrix: Array,
                // index describing which entry in payoff matrix is to be used by this player
                payoffIndex: Number,
                // boolean to choose whether or not to show opponent's heatmap
                opponentHeatmap: String,
                // associative array relating participant code to current decision
                // holds this player's decision and the opponent's decision
                decisions: {
                    type: Object,
                    observer: '_decisionsChanged'
                },
                // path to use with firebase
                path_: String,
                periodLength: Number
            },
            listeners: {
                'keyup': '_setMyDecision'
            },
            ready() {
                // set firebase path to appropriate scope
                this.path_ = (
                '/session/' + this.$.vars.session +
                '/app/' + this.$.vars.appName +
                '/subsession/' + this.$.vars.subsession +
                '/round/' + this.$.vars.round +
                '/group/' + this.$.vars.group +
                '/page/' + this.$.vars.page +
                '/component/otree-bimatrix' +
                '/decisions');
                // variables for this player's decision and the opponent's decision
                this.my_decision = .5;
                this.other_decision = .5;
                this.otherPayoffIndex = this.payoffIndex == 0 ? 1 : 0;

                // separate each player's payoffs into two separate arrays
                this.my_payoffs = this.payoffMatrix.map(function (current_val) {
                    return parseInt(current_val[this.payoffIndex]);
                }, this);

                this.other_payoffs = this.payoffMatrix.map(function (current_val) {
                        return parseInt(current_val[this.otherPayoffIndex]);
                }, this);

                // make this player's heatmap
                make_heatmap("my-canvas", this.my_payoffs);

                // if opponentHeatmap is true, take inverse of other player's payoffs and display their heatmap
                if (this.opponentHeatmap == "true") {
                    this.$["other-bimatrix-container"].style.display = "";
                    var other_payoffs = this.other_payoffs.slice();
                    var tmp = other_payoffs[1];
                    other_payoffs[1] = other_payoffs[2];
                    other_payoffs[2] = tmp;
                    make_heatmap("other-canvas", other_payoffs);
                }

                // initialize thermometer
                make_thermometer("thermometer");
            },
            attached() {
                this._setupPayoffGraph();
                this._setupStrategyGraph();
                this.start_time = performance.now();
                // start update function
                window.requestAnimationFrame(this._updateGraph.bind(this));
            },
            // compare two decisions
            _equals(d, decision) {
                return d == decision;
            },
            // set my current decision. triggered by the player releasing the slider
            _setMyDecision(event) {
                if (event.type === 'keyup' && !(event.key === 'ArrowDown') && !(event.key === 'ArrowUp')) {
                    return;
                }
                var d = parseFloat(event.target.value);
                // if decisions hasn't been created yet, create it
                if (this.decisions === null) {
                    this.decisions = {};
                }
                // pcode is this player's participant code
                var pcode = this.$.vars.participantCode;
                // use polymer this.set to change decisions. I don't really know why I have to do this but it doesn't work if I don't
                this.set('decisions.' + pcode, d);
                this.my_decision = d;

                this._graphUpdatePayoffs();
            },
            // listener on firebase decisions array. reacts to the opponent changing their strategy
            _decisionsChanged() {
                if (this.decisions === null) {
                    return;
                }
                var pcode = this.$.vars.participantCode;
                // if I haven't set a decision yet, use my decision from firebase. here in case someone refreshes the page
                if (this.decisions[pcode]) {
                    this.my_decision = this.decisions[pcode];
                    this.$.slider.value = this.my_decision;
                }

                // get other player's decision by picking the key that isn't yours
                // there's probably a better way of doing this
                for (var key in this.decisions) {
                    if (key != pcode) {
                        this.other_decision = this.decisions[key];

                        this._graphUpdatePayoffs();
                        break;
                    }
                }
            },
            // format a decision as a CSS percent value
            _calcPercent(decision) {
                return decision * 100 + "%";
            },
            // returns a specific entry in the payoff table. I don't really know what's going on here, it's more polymer weirdness
            _payoff: function (change, x, y) {
                return change.base[x][y];
            },
            // sets up payoff over time graph
            _setupPayoffGraph() {
                // readability is overrated
                // just sums each set of payoffs and divides by 4
                var myInitialPayoff = this.my_payoffs.reduce((a, b) => a + b, 0) / 4;
                var otherInitialPayoff = this.other_payoffs.reduce((a, b) => a + b, 0) / 4;
                // finds max of all payoffs
                var maxPayoff = Math.max.apply(null, this.my_payoffs.concat(this.other_payoffs));

                // call highcharts setup function
                this.payoff_graph_obj = Highcharts.chart({
                    chart: {
                        animation: false,
                        renderTo: 'payoff_graph',
                    },
                    title: { text: null },
                    exporting: { enabled: false },
                    tooltip: { enabled: false },
                    legend: { enabled: false },
                    xAxis: {
                        min: 0,
                        max: 1,
                        labels: { enabled: false }
                    },
                    yAxis: {
                        title: { text: undefined },
                        min: 0,
                        max: maxPayoff
                    },
                    line: {
                        marker: {
                            enabled: false,
                            states: {
                                hover: { enabled: false },
                                select: { enabled: false }
                            }
                        }
                    },
                    series: [
                        {
                            type: "area",
                            data: [[0, myInitialPayoff], [0, myInitialPayoff]],
                            step: "left"
                        },
                        {
                            type: "line",
                            data: [[0, otherInitialPayoff], [0, otherInitialPayoff]],
                            step: "left"
                        }
                    ]
                });
            },
            // sets up strategy over time graph
            _setupStrategyGraph() {
                // call highcharts setup function
                this.strategy_graph_obj = Highcharts.chart({
                    chart: {
                        animation: false,
                        renderTo: 'strategy_graph',
                        type: 'line',
                    },
                    title: { text: null },
                    exporting: { enabled: false },
                    tooltip: { enabled: false },
                    legend: { enabled: false },
                    xAxis: {
                        min: 0,
                        max: 1,
                        labels: { enabled: false }
                    },
                    yAxis: {
                        title: { text: undefined },
                        min: 0,
                        max: 1
                    },
                    line: {
                        marker: {
                            enabled: false,
                            states: {
                                hover: { enabled: false },
                                select: { enabled: false }
                            }
                        }
                    },
                    series: [{
                        data: [ [0, .5], [0, .5] ],
                        step: "left"
                    },
                    {
                        data: [ [0, .5], [0, .5] ],
                        step: "left"
                    }]
                });
            },
            // updates current payoff value every 50 ms
            _updateGraph(timestamp) {
                // calculate x value for current time
                var xval = (timestamp - this.start_time) / (this.periodLength * 1000);

                var dataset = this.payoff_graph_obj.series[0];
                var len = dataset.data.length;
                dataset.data[len - 1].update({x: xval});

                dataset = this.payoff_graph_obj.series[1];
                len = dataset.data.length;
                dataset.data[len - 1].update({x: xval});

                dataset = this.strategy_graph_obj.series[0];
                len = dataset.data.length;
                dataset.data[len - 1].update({x: xval});  

                dataset = this.strategy_graph_obj.series[1];
                len = dataset.data.length;
                dataset.data[len - 1].update({x: xval});

                // recursively call update
                window.requestAnimationFrame(this._updateGraph.bind(this));              
            },
            // is called everytime someone's decision changes and update payoff graph
            _graphUpdatePayoffs() {
                // if graph hasn't been initialized, don't do anything
                if (!this.payoff_graph_obj) return;

                // calculate the payoff with current decision values
                var my_point_payoff = (this.my_decision * this.other_decision * this.my_payoffs[0]) +
                                      (this.my_decision * (1 - this.other_decision) * this.my_payoffs[1]) +
                                      ((1 - this.my_decision) * this.other_decision * this.my_payoffs[2]) +
                                      ((1 - this.my_decision) * (1 - this.other_decision) * this.my_payoffs[3]);

               var other_point_payoff = (this.other_decision * this.my_decision * this.other_payoffs[0]) +
                                        (this.other_decision * (1 - this.my_decision) * this.other_payoffs[1]) +
                                        ((1 - this.other_decision) * this.my_decision * this.other_payoffs[2]) +
                                        ((1 - this.other_decision) * (1 - this.my_decision) * this.other_payoffs[3]);

                // calculate new decision's timestamp as a value between 0 and 1
                var xval = (performance.now() - this.start_time) / (this.periodLength * 1000);

                dataset = this.strategy_graph_obj.series[0];
                len = dataset.data.length;
                dataset.data[len - 1].remove();
                dataset.addPoint([xval, this.my_decision], false, false);
                dataset.addPoint([xval, this.my_decision], true, false);

                dataset = this.strategy_graph_obj.series[1];
                len = dataset.data.length;
                dataset.data[len - 1].remove();
                dataset.addPoint([xval, this.other_decision], false, false);
                dataset.addPoint([xval, this.other_decision], true, false);

                // add point for my payoff
                var dataset = this.payoff_graph_obj.series[0];
                var len = dataset.data.length;
                dataset.data[len - 1].remove();
                dataset.addPoint([xval, my_point_payoff], false, false);
                dataset.addPoint([xval, my_point_payoff], true, false);

                // add point for other payoff
                dataset = this.payoff_graph_obj.series[1];
                len = dataset.data.length;
                dataset.data[len - 1].remove();
                dataset.addPoint([xval, other_point_payoff], false, false);
                dataset.addPoint([xval, other_point_payoff], true, false);
            }
        });
    </script>

</dom-module>