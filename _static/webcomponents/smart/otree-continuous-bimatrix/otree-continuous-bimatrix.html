<link rel="import" href="/static/bower_components/polymer/polymer.html"/>
<link rel="import" href="/static/bower_components/polymerfire/firebase-document.html"/>
<link rel="import" href="/static/webcomponents/otree-vars/otree-vars.html"/>
<link rel="import" href="/static/webcomponents/otree-log/otree-log.html"/>

<link rel="import" href="/static/webcomponents/reusable/otree-heatmap/otree-heatmap.html"/>
<link rel="import" href="/static/webcomponents/reusable/otree-thermometer/otree-thermometer.html"/>

<script src="/static/general/color.js"></script>

<dom-module id="otree-continuous-bimatrix">
    <template>
        <link rel="stylesheet" type="text/css" href="styles.css">
        <firebase-document
                id="fbdoc"
                path="[[path_]]"
                data="{{ decisions }}">
        </firebase-document>
        <otree-vars id="vars"></otree-vars>
        <otree-log id="log"></otree-log>

        <div id="experiment-container">
            
            <div id="my-bimatrix-container">
                <input id="slider" type="range" min="0" max="1" step=".01" defaultValue=".5" on-up="_setMyDecision"/>

                <div id="my-heatmap">
                    <otree-heatmap
                        width='300'
                        height='300'
                        my-decision='[[my_decision]]'
                        other-decision='[[other_decision]]'
                        payoffs='[[my_payoffs]]'
                        color='[[my_color]]'
                    ></otree-heatmap>
                </div>
            </div>

            <div id="other-bimatrix-container">
                <div id="other-heatmap">
                    <otree-heatmap
                        width='120'
                        height='120'
                        my-decision='[[other_decision]]'
                        other-decision='[[my_decision]]'
                        payoffs='[[other_payoffs_transpose]]'
                        color='[[other_color]]'
                    ></otree-heatmap>
                </div>
            </div>

            <div class="graph-container">
                <div id="strategy_graph"></div>
                <otree-thermometer
                    color='rainbow'
                ></otree-thermometer>
                <div id="payoff_graph"></div>
            </div>
        </div>

    </template>

    <script>
        Polymer({
            is: 'otree-continuous-bimatrix',
            properties: {
                payoffMatrix: Array,
                decisions: {
                    type: Object,
                    observer: '_decisionsChanged'
                },
                path_: String,
                periodLength: Number
            },
            listeners: {
                keyup: '_setMyDecision'
            },
            ready() {
                this.path_ = (
                '/session/' + this.$.vars.session +
                '/app/' + this.$.vars.appName +
                '/subsession/' + this.$.vars.subsession +
                '/round/' + this.$.vars.round +
                '/group/' + this.$.vars.group +
                '/page/' + this.$.vars.page +
                '/component/otree-bimatrix' +
                '/decisions')

                // this.payoffIndex = this.$.vars.idInGroup - 1 // USE IN REAL THING
                this.payoffIndex = 0 // USE IN DEMO.HTML

                this.otherPayoffIndex = this.payoffIndex === 0 ? 1 : 0

                // variables for this player's decision and the opponent's decision
                this.my_decision = .5
                this.other_decision = .5

                // color schemes for each player's heatmaps
                this.my_color = 'rainbow'
                this.other_color = 'mono'

                // separate each player's payoffs into two separate arrays
                this.my_payoffs = this.payoffMatrix.map(val => parseInt(val[this.payoffIndex]))
                this.other_payoffs = this.payoffMatrix.map(val => parseInt(val[this.otherPayoffIndex]))

                // take inverse of other player's payoffs
                const other_payoffs_transpose = this.other_payoffs.slice()
                const tmp = other_payoffs_transpose[1]
                other_payoffs_transpose[1] = other_payoffs_transpose[2]
                other_payoffs_transpose[2] = tmp
                this.other_payoffs_transpose = other_payoffs_transpose
            },
            attached() {
                this._setupPayoffGraph()
                this._setupStrategyGraph()
                this.start_time = performance.now()
                // start update function
                window.requestAnimationFrame(this._updateGraph.bind(this))
            },
            // helper method to return last element of array
            _lastElem(arr) {
                return arr[arr.length - 1]
            },
            // set my current decision. triggered by the player releasing the slider
            _setMyDecision(event) {
                if (event.key == 'ArrowDown' || event.key == 'ArrowUp') {
                    const d = parseFloat(event.target.value)
                    // if decisions hasn't been created yet, create it
                    this.decisions = this.decisions || {}
                    // pcode is this player's participant code
                    const pcode = this.$.vars.participantCode
                    // use polymer this.set to change decisions. I don't really know why I have to do this but it doesn't work if I don't
                    this.set('decisions.' + pcode, d)
                    this.my_decision = d

                    this._graphUpdatePayoffs()
                }
            },
            // listener on firebase decisions array. reacts to the opponent changing their strategy
            _decisionsChanged() {
                if (this.decisions === null)
                    return

                const pcode = this.$.vars.participantCode
                // if I haven't set a decision yet, use my decision from firebase. here in case someone refreshes the page
                if (this.decisions[pcode]) {
                    this.my_decision = this.decisions[pcode]
                    this.$.slider.value = this.my_decision
                }

                // get other player's decision by picking the key that isn't yours
                // there's probably a better way of doing this
                for (let key in this.decisions) {
                    if (key != pcode) {
                        this.other_decision = this.decisions[key]

                        this._graphUpdatePayoffs()
                        break
                    }
                }
            },
            // sets up payoff over time graph
            _setupPayoffGraph() {
                // readability is overrated
                // just sums each set of payoffs and divides by 4
                const myInitialPayoff = this.my_payoffs.reduce((a, b) => a + b, 0) / 4
                const otherInitialPayoff = this.other_payoffs.reduce((a, b) => a + b, 0) / 4
                // finds max of all payoffs
                const maxPayoff = Math.max.apply(null, this.my_payoffs.concat(this.other_payoffs))

                // call highcharts setup function
                this.payoff_graph_obj = Highcharts.chart({
                    chart: {
                        animation: false,
                        renderTo: 'payoff_graph',
                        enabled: false,
                    },
                    title: { text: null },
                    exporting: { enabled: false },
                    tooltip: { enabled: false },
                    legend: { enabled: false },
                    credits: { enabled: false },
                    xAxis: {
                        min: 0,
                        max: 1,
                        labels: { enabled: false }
                    },
                    yAxis: {
                        title: { text: undefined },
                        min: 0,
                        max: maxPayoff,
                        endOnTick: false,
                        tickInterval: maxPayoff / 4
                    },
                    plotOptions: {
                        line: {marker: {enabled: false}},
                        area: {marker: {enabled: false}},
                        series: {
                            states: {
                                hover: {
                                    enabled: false,
                                }
                            }
                       }
                    },
                    line: {
                        marker: {
                            enabled: false,
                            states: {
                                hover: { enabled: false },
                                select: { enabled: false }
                            }
                        }
                    },
                    series: [
                        {
                            type: "area",
                            data: [[0, myInitialPayoff], [0, myInitialPayoff]],
                            step: "left"
                        },
                        {
                            type: "line",
                            data: [[0, otherInitialPayoff], [0, otherInitialPayoff]],
                            step: "left"
                        }
                    ]
                })
            },
            // sets up strategy over time graph
            _setupStrategyGraph() {
                // call highcharts setup function
                this.strategy_graph_obj = Highcharts.chart({
                    chart: {
                        animation: false,
                        renderTo: 'strategy_graph',
                        type: 'line',
                    },
                    title: { text: null },
                    exporting: { enabled: false },
                    tooltip: { enabled: false },
                    legend: { enabled: false },
                    credits: { enabled: false },
                    xAxis: {
                        min: 0,
                        max: 1,
                        labels: { enabled: false }
                    },
                    yAxis: {
                        title: { text: undefined },
                        min: 0,
                        max: 1
                    },
                    plotOptions: {
                        line: {marker: {enabled: false}},
                        series: {
                            states: {
                                hover: {
                                    enabled: false,
                                }
                            }
                        }
                    },
                    line: {
                        marker: {
                            enabled: false,
                            states: {
                                hover: { enabled: false },
                                select: { enabled: false }
                            }
                        }
                    },
                    series: [{
                        data: [ [0, .5], [0, .5] ],
                        step: "left"
                    },
                    {
                        data: [ [0, .5], [0, .5] ],
                        step: "left"
                    }]
                })
            },
            // updates current payoff value every 50 ms
            _updateGraph(timestamp) {
                // calculate x value for current time
                const xval = (timestamp - this.start_time) / (this.periodLength * 1000)

                let dataset
                dataset = this.payoff_graph_obj.series[0]
                this._lastElem(dataset.data).update({x: xval})

                dataset = this.payoff_graph_obj.series[1]
                len = dataset.data.length
                this._lastElem(dataset.data).update({x: xval})

                dataset = this.strategy_graph_obj.series[0]
                this._lastElem(dataset.data).update({x: xval})

                dataset = this.strategy_graph_obj.series[1]
                this._lastElem(dataset.data).update({x: xval})

                // recursively call update
                window.requestAnimationFrame(this._updateGraph.bind(this))
            },
            // is called everytime someone's decision changes and update payoff graph
            _graphUpdatePayoffs() {
                // if graph hasn't been initialized, don't do anything
                if (!this.payoff_graph_obj) return

                // calculate the payoff with current decision values
                const my_point_payoff =
                    (this.my_decision * this.other_decision * this.my_payoffs[0]) +
                    (this.my_decision * (1 - this.other_decision) * this.my_payoffs[1]) +
                    ((1 - this.my_decision) * this.other_decision * this.my_payoffs[2]) +
                    ((1 - this.my_decision) * (1 - this.other_decision) * this.my_payoffs[3])

                const other_point_payoff =
                    (this.other_decision * this.my_decision * this.other_payoffs[0]) +
                    (this.other_decision * (1 - this.my_decision) * this.other_payoffs[1]) +
                    ((1 - this.other_decision) * this.my_decision * this.other_payoffs[2]) +
                    ((1 - this.other_decision) * (1 - this.my_decision) * this.other_payoffs[3])

                // calculate new decision's timestamp as a value between 0 and 1
                const xval = (performance.now() - this.start_time) / (this.periodLength * 1000)

                let dataset
                // add point for my new decision
                dataset = this.strategy_graph_obj.series[0]
                this._lastElem(dataset.data).remove()
                dataset.addPoint([xval, this.my_decision], false, false)
                dataset.addPoint([xval, this.my_decision], true, false)

                // add point for others' new decision
                dataset = this.strategy_graph_obj.series[1]
                this._lastElem(dataset.data).remove()
                dataset.addPoint([xval, this.other_decision], false, false)
                dataset.addPoint([xval, this.other_decision], true, false)

                // add point for my payoff
                dataset = this.payoff_graph_obj.series[0]
                this._lastElem(dataset.data).remove()
                dataset.addPoint([xval, my_point_payoff], false, false)
                dataset.addPoint([xval, my_point_payoff], true, false)

                // add point for other payoff
                dataset = this.payoff_graph_obj.series[1]
                this._lastElem(dataset.data).remove()
                dataset.addPoint([xval, other_point_payoff], false, false)
                dataset.addPoint([xval, other_point_payoff], true, false)
            }
        })
    </script>

</dom-module>